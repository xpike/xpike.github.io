{
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Add your introductions here! | xPike",
    "keywords": "Add your introductions here!"
  },
  "api/extensions/articles/verifying-the-container.html": {
    "href": "api/extensions/articles/verifying-the-container.html",
    "title": "Verifying the Container | xPike",
    "keywords": "Verifying the Container A common mistake we make is forgetting to register a type with the container. Another is having a singleton depend on a transient (or other lesser scoped) registration. xPike Extensions solves this by providing the cabability to verify your IServiceProvider instance at startup. This ensures that: All root objects and their dependencies can be resolved. Singletons only depend on other singletons. Scoped registrations only depend on singletons and other scoped registrations. Verifying the container configuration at startup can signifcantly reduce production issues caused by missing or improper registrations not identified during testing. Step 1 Install the XPike.Extensions.DependencyInjection package: dotnet add package XPike.Extensions.DependencyInjection or Install-Package XPike.Extensions.DependencyInjection Step 2 Call the extension method on IServiceCollection to add the verification functionality to the provider: using Xpike.Extensions.DependencyInjection; ... public void ConfigureServices(IServiceCollection services) { services.AddMvc(); ... services.AddServiceProviderVerification(); } Step 3 Call the extension method on IServiceProvider to add the verify the container: public void Configure(IApplicationBuilder app, IHostingEnvironment env) { app.ApplicationServices.Verify(); //this should be the first thing you do. ... app.UseMvc(); } Performance Considerations There is a performance hit at startup. The impact depends on the number of registrations. You may want to only verify the container in non-production environments. Assuming you have your ASPNETCORE_ENVIRONMENT set properly for each environment, you can simply... public void Configure(IApplicationBuilder app, IHostingEnvironment env) { if (!env.IsProduction()) app.ApplicationServices.Verify(); ... app.UseMvc(); }"
  },
  "api/extensions/articles/intro.html": {
    "href": "api/extensions/articles/intro.html",
    "title": "Introduction | xPike",
    "keywords": "Introduction xPike Extensions provides features enhancements to Microsoft.Extensions. Packages XPike.Extensions.DependencyInjection The XPike.Extensions.DependencyInjection package add functionality to Microsoft's DI container ( Microsoft.Extensions.DependencyInjection ). These extensions can be used independent of the xPike paved-road and take no dependencies on other xPike packages. XPike.Extensions.DependencyInjection.WebApi The XPike.Extensions.WebApi package provides support for using Microsoft.Extensions.DependencyInjection in legacy ASP.Net WebAPI applications."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "xPike Guides and API Documentation | xPike",
    "keywords": "xPike Guides and API Documentation xPike Extensions xPike Extensions provides features enhancements to Microsoft.Extensions. These extensions can be used independent of the xPike paved-road and take no dependencies on other xPike packages. IoC - Dependency Injection Inversion of Control/Dependency Injection abstractions to support the rest of xPike."
  },
  "api/extensions/api/XPike.Extensions.DependencyInjection.html": {
    "href": "api/extensions/api/XPike.Extensions.DependencyInjection.html",
    "title": "Namespace XPike.Extensions.DependencyInjection | xPike",
    "keywords": "Namespace XPike.Extensions.DependencyInjection Classes IServiceCollectionExtensions Extension methods for IServiceCollection. IServiceProviderExtensions Extension methods for IServiceProvider, to enhance the features and functionality of Microsoft.Extensions.DependencyInjection. ServiceProviderVerificationException A ServiceProviderVerificationException is thrown when the container fails to verify. VerificationResult Encapsulates the result of a failed attempt to verify a registered type in the container."
  },
  "api/extensions/api/XPike.Extensions.DependencyInjection.ServiceProviderVerificationException.html": {
    "href": "api/extensions/api/XPike.Extensions.DependencyInjection.ServiceProviderVerificationException.html",
    "title": "Class ServiceProviderVerificationException | xPike",
    "keywords": "Class ServiceProviderVerificationException A ServiceProviderVerificationException is thrown when the container fails to verify. Inheritance System.Object System.Exception ServiceProviderVerificationException Implements System.Runtime.Serialization.ISerializable System.Runtime.InteropServices._Exception Inherited Members System.Exception.GetBaseException() System.Exception.ToString() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.Message System.Exception.Data System.Exception.InnerException System.Exception.TargetSite System.Exception.StackTrace System.Exception.HelpLink System.Exception.Source System.Exception.HResult System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() Namespace : XPike.Extensions.DependencyInjection Assembly : XPike.Extensions.DependencyInjection.dll Syntax [Serializable] public class ServiceProviderVerificationException : Exception, ISerializable, _Exception Constructors ServiceProviderVerificationException(IEnumerable<VerificationResult>) Initializes a new instance of the ServiceProviderVerificationException class. Declaration public ServiceProviderVerificationException(IEnumerable<VerificationResult> results) Parameters Type Name Description System.Collections.Generic.IEnumerable < VerificationResult > results The exceptions. ServiceProviderVerificationException(SerializationInfo, StreamingContext) Initializes a new instance of the ServiceProviderVerificationException class. Declaration protected ServiceProviderVerificationException(SerializationInfo serializationInfo, StreamingContext streamingContext) Parameters Type Name Description System.Runtime.Serialization.SerializationInfo serializationInfo The serialization information. System.Runtime.Serialization.StreamingContext streamingContext The streaming context. Exceptions Type Condition System.NotImplementedException Properties Restults Gets a list of VerificationResult s that occurred during verification. Declaration public IEnumerable<VerificationResult> Restults { get; } Property Value Type Description System.Collections.Generic.IEnumerable < VerificationResult > An array of exceptions. Implements System.Runtime.Serialization.ISerializable System.Runtime.InteropServices._Exception See Also System.Exception"
  },
  "api/extensions/api/XPike.Extensions.DependencyInjection.IServiceCollectionExtensions.html": {
    "href": "api/extensions/api/XPike.Extensions.DependencyInjection.IServiceCollectionExtensions.html",
    "title": "Class IServiceCollectionExtensions | xPike",
    "keywords": "Class IServiceCollectionExtensions Extension methods for IServiceCollection. Inheritance System.Object IServiceCollectionExtensions Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : XPike.Extensions.DependencyInjection Assembly : XPike.Extensions.DependencyInjection.dll Syntax public static class IServiceCollectionExtensions Methods AddServiceProviderVerification(IServiceCollection) Configures the service collection so it can later be verfied by the service provider. Declaration public static IServiceCollection AddServiceProviderVerification(this IServiceCollection services) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceCollection services This IServicesCollection instance. Returns Type Description Microsoft.Extensions.DependencyInjection.IServiceCollection IServiceCollection."
  },
  "api/extensions/api/XPike.Extensions.DependencyInjection.IServiceProviderExtensions.html": {
    "href": "api/extensions/api/XPike.Extensions.DependencyInjection.IServiceProviderExtensions.html",
    "title": "Class IServiceProviderExtensions | xPike",
    "keywords": "Class IServiceProviderExtensions Extension methods for IServiceProvider, to enhance the features and functionality of Microsoft.Extensions.DependencyInjection. Inheritance System.Object IServiceProviderExtensions Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : XPike.Extensions.DependencyInjection Assembly : XPike.Extensions.DependencyInjection.dll Syntax public static class IServiceProviderExtensions Methods Verify(IServiceProvider) Verifies the dependency graph for completeness and valid dependency lifetimes. This method is thread-safe. Declaration public static void Verify(this IServiceProvider provider) Parameters Type Name Description System.IServiceProvider provider This IServiceProvider instance. Remarks This method also ensures that singletons only depend on other singletons and that scoped objects only depend on singletons and other scoped objects. Having a singleton depend on a transient object effectively makes that transient object a singleton and could result in undesired behavior. Examples public void Configure(IApplicationBuilder app, IHostingEnvironment env) { app.ApplicationServices.Verify(); ... app.UseMvc(); } Exceptions Type Condition System.InvalidOperationException The container has already been verified. System.InvalidOperationException IServiceCollection must be registerd in order to verify the provider. Verify() needs to obtain the list of registered services from the IServiceCollection instance. ServiceProviderVerificationException The container is invalid."
  },
  "articles/contributing.html": {
    "href": "articles/contributing.html",
    "title": "Contributing | xPike",
    "keywords": "Contributing The project maintainers maintain guidelines for contributing to the xPike repos. A team member will be happy to explain why a guideline is defined as it is. General contribution guidance is included in this document. Up for Grabs Project maintainers mark the most straightforward issues as \"up for grabs\". This set of issues is the place to start if you are interested in contributing but new to the codebase. Contribution \"Bar\" Project maintainers will merge changes that improve the product significantly and broadly and that align with the project mission. Maintainers will not merge changes that have narrowly-defined benefits, due to compatibility risk. Our goal is to keep they project broad and extensible, rather than specific and too opinionated. You are welcome to create your own project/library that extends xPike. If you are unsure, please open an issue and we will be happy to discuss. We may revert changes if they are found to be breaking. Contributions must also satisfy the other published guidelines defined in this document. DOs and DON'Ts Please do: DO follow our coding style (C# code-specific) DO give priority to the current style of the project or file you're changing even if it diverges from the general guidelines. DO include tests when adding new features. When fixing bugs, start with adding a test that highlights how the current behavior is broken. Changes without corresponding tests will be rejected. DO include documentation when adding new features. Changes without corresponding documentation will be rejected. DO keep the discussions focused. When a new or related topic comes up it's often better to create new issue than to side track the discussion. DO blog and tweet (or whatever) about your contributions, frequently! Please do not: DON'T make PRs for style changes. DON'T surprise us with big pull requests. Instead, file an issue and start a discussion so we can agree on a direction before you invest a large amount of time. DON'T commit code that you didn't write. If you find code that you think is a good fit to add to xPike, file an issue and start a discussion before proceeding. DON'T submit PRs that alter licensing related files or headers. If you believe there's a problem with them, file an issue and we'll be happy to discuss it. DON'T add API additions without filing an issue and discussing with us first. Commit Messages Please format commit messages as follows (based on A Note About Git Commit Messages ): Summarize change in 50 characters or less Provide more detail after the first line. Leave one blank line below the summary and wrap all lines at 72 characters or less. If the change fixes an issue, leave another blank line after the final paragraph and indicate which issue is fixed in the specific format below. Fix #42 Do your best to factor commits appropriately, not too large with unrelated things in the same commit, and not too small with the same small change applied N times in N different commits. File Headers The following file header is the used for xPike. Please use it for new files. // This file is licensed under the MIT license. // See the LICENSE file in the project root for more information. Copying Files from Other Projects xPike uses some files from other projects, typically where a binary distribution does not exist or would be inconvenient. The following rules must be followed for PRs that include files from another project: The license of the file is permissive . Ideally, MIT. The license of the file is left in-tact. The contribution is correctly attributed in the 3rd party notices file in the repository, as needed. Porting Files from Other Projects There are many good algorithms implemented in other languages that would benefit the xPike project. The rules for porting a Java file to C# , for example, are the same as would be used for copying the same file, as described above. Clean-room implementations of existing algorithms that are not permissively licensed will generally not be accepted. If you want to create or nominate such an implementation, please create an issue to discuss the idea. C# Coding Style For non code files (xml, etc), our current best guidance is consistency. When editing files, keep new code and changes consistent with the style in the files. For new files, it should conform to the style for that component. If there is a completely new component, anything that is reasonably broadly accepted is fine. The general rule we follow is \"use Visual Studio defaults\". We use Allman style braces, where each brace begins on a new line. A single line statement block can go without braces but the block must be properly indented on its own line and must not be nested in other statement blocks that use braces. One exception is that a using statement is permitted to be nested within another using statement by starting on the following line at the same indentation level, even if the nested using contains a controlled block. We use four spaces of indentation (no tabs). We use camelCase for internal and private fields and use readonly where possible. Prefix internal and private static fields with _ . When used on static fields, readonly should come after static (e.g. static readonly not readonly static ). Public fields should be used sparingly and only if they are readonly . We use this. when necessary. We always specify the visibility, even if it's the default (e.g. private string foo not string foo ). This is to explicitly express intent. Visibility should be the first modifier (e.g. public abstract not abstract public ). Namespace imports should be specified at the top of the file, outside of namespace declarations, and should be sorted alphabetically, with the exception of System.* namespaces, which are to be placed on top of all others. Avoid more than one empty line at any time. For example, do not have two blank lines between members of a type. Avoid spurious free spaces. For example avoid if (someVar == 0)... , where the dots mark the spurious free spaces. Consider enabling \"View White Space (Ctrl+E, S)\" if using Visual Studio to aid detection. If a file happens to differ in style from these guidelines (e.g. private members are named m_member rather than member ), the existing style in that file takes precedence. We only use var when it's obvious what the variable type is (e.g. var stream = new FileStream(...) not var stream = OpenStandardInput() ). We use language keywords instead of BCL types (e.g. int, string, float instead of Int32, String, Single , etc) for both type references as well as method calls (e.g. int.Parse instead of Int32.Parse ). We use CAPITALIZED_SNAKE_CASING to name all our constant local variables and fields. The only exception is for interop code where the constant value should exactly match the name and value of the code you are calling via interop. We use nameof(...) instead of \"...\" whenever possible and relevant. Fields should be specified at the top within type declarations. When including non-ASCII characters in the source code use Unicode escape sequences (\\uXXXX) instead of literal characters. Literal non-ASCII characters occasionally get garbled by a tool or editor. All public members must have XML comments documentation. We use DocFX to generate the documentation, so you may use DocFX Markdown in the these comments. Undocumented public members will be rejected. An EditorConfig file ( .editorconfig ) has been provided at the root of the repository, enabling C# auto-formatting conforming to the above guidelines."
  },
  "api/ioc/articles/intro.html": {
    "href": "api/ioc/articles/intro.html",
    "title": "Introduction | xPike",
    "keywords": "Introduction xPike IoC provides inversion of control and dependency injection abstractions and default implementations for the xPike paved-road. Packages XPike.IoC Abstractions used by the rest of xPike. Xpike.IoC.Owin Support for using xPike dependency injection in Owin applications. XPike.IoC.Microsoft An XPike.IoC provider implementation for Microsoft.Extensions.DependencyInjection. Xpike.IoC.SimpleInjector An XPike.IoC provider implementation for SimpleInjector."
  },
  "api/extensions/articles/using-msid-in-webapi.html": {
    "href": "api/extensions/articles/using-msid-in-webapi.html",
    "title": "Using Microsoft.Extensions.DependencyInjection in Asp.Net WebAPI | xPike",
    "keywords": "Using Microsoft.Extensions.DependencyInjection in Asp.Net WebAPI Global.asax.cs public class WebApiApplication : System.Web.HttpApplication { protected void Application_Start() { GlobalConfiguration.Configure(WebApiConfig.Register); // Create a new service collection IServiceCollection services = new ServiceCollection(); // Add your services services.AddSingleton<ILogger, Logger>(); // Add the WebApi controllers to the collection services.AddApiControllers(); // Create and verify the service provider IServiceProvider provider = services.BuildServiceProvider(); provider.Verify(); // Tell WebAPI it use Microsoft.Extensions.DependencyInjection // to resolve dependencies GlobalConfiguration.Configuration.DependencyResolver = new MicrosoftDependencyResolver(provider); // Resolve and start any background services... ILogger logger = provider.GetService<ILogger>(); logger.LogInfo(\"Service Started\"); } }"
  },
  "api/extensions/api/index.html": {
    "href": "api/extensions/api/index.html",
    "title": "Introduction | xPike",
    "keywords": "Introduction xPike Extensions provides features enhancements to Microsoft.Extensions. Packages XPike.Extensions.DependencyInjection The XPike.Extensions.DependencyInjection package add functionality to Microsoft's DI container ( Microsoft.Extensions.DependencyInjection ). These extensions can be used independent of the xPike paved-road and take no dependencies on other xPike packages. XPike.Extensions.DependencyInjection.WebApi The XPike.Extensions.WebApi package provides support for using Microsoft.Extensions.DependencyInjection in legacy ASP.Net WebAPI applications."
  },
  "index.html": {
    "href": "index.html",
    "title": "xPike - The Paved-Road for Microservices in .Net | xPike",
    "keywords": "xPike - The Paved-Road for Microservices in .Net Mission Provide a paved road of cross-cutting concerns and best practices for building high quality, reliable, cloud-native microservices and distributed systems in .Net and .Net Core. Highlights Key goals are to provide a cross-cutting, cohesive framework which suggests a single paved road to success, without constraining you to follow that path. While we try not to be opinioned like other frameworks, we do provide sensible defaults. Highly pluggable and customizable, strongly encourages and enables test-oriented development. Primary feature set targeting \"universal areas of concern\" such as logging, metrics, settings management, dependency injection, data access, inter-service communication (events, queues, HTTP, gRPC), transient fault management (\"circuit breakers\"), etc. Providers are available for common RDBMS systems, cloud services in AWS and Azure, familiar .NET libraries, and many other use cases - it is also easy to create your own custom providers. Using a highly de-coupled architecture and a contract-based design pattern, it is well suited for an evolving service ecosystem and simplifies the decomposition of legacy systems. The \"Paved-Road\" The xPike SDK aims to provide a paved-road of industry demonstrated best practices in service design and operation, including: SOLID principles Observability Configuration separate from code Abstract infrastructure concerns from application logic Platform Support Natively support: .Net Core 2.0 and above .Net 4.5.2 and above Contributing Want to contribute? Read our contributing guidelines . Licensing License information can be found here ."
  },
  "articles/license.html": {
    "href": "articles/license.html",
    "title": "License | xPike",
    "keywords": "License All xPike code and packages are licensed under the MIT license and are free to use in commercial production environments. MIT License Copyright (c) 2019, xPike committers Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "api/extensions/api/XPike.Extensions.DependencyInjection.WebApi.html": {
    "href": "api/extensions/api/XPike.Extensions.DependencyInjection.WebApi.html",
    "title": "Namespace XPike.Extensions.DependencyInjection.WebApi | xPike",
    "keywords": "Namespace XPike.Extensions.DependencyInjection.WebApi Classes IServiceCollectionExtensions Extension methods for IServiceCollection to support using Microsoft.Extensions.DependencyInjection in ASP.Net WebAPI. MicrosoftDependencyResolver Class MicrosoftDependencyResolver. This class cannot be inherited. Implements the System.Web.Http.Dependencies.IDependencyResolver"
  },
  "api/extensions/api/XPike.Extensions.DependencyInjection.WebApi.MicrosoftDependencyResolver.html": {
    "href": "api/extensions/api/XPike.Extensions.DependencyInjection.WebApi.MicrosoftDependencyResolver.html",
    "title": "Class MicrosoftDependencyResolver | xPike",
    "keywords": "Class MicrosoftDependencyResolver Class MicrosoftDependencyResolver. This class cannot be inherited. Implements the System.Web.Http.Dependencies.IDependencyResolver Inheritance System.Object MicrosoftDependencyResolver Implements System.Web.Http.Dependencies.IDependencyResolver System.Web.Http.Dependencies.IDependencyScope System.IDisposable Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : XPike.Extensions.DependencyInjection.WebApi Assembly : XPike.Extensions.DependencyInjection.WebApi.dll Syntax public sealed class MicrosoftDependencyResolver : IDependencyResolver, IDependencyScope, IDisposable Constructors MicrosoftDependencyResolver(IServiceProvider) Initializes a new instance of the MicrosoftDependencyResolver class. Declaration public MicrosoftDependencyResolver(IServiceProvider serviceProvider) Parameters Type Name Description System.IServiceProvider serviceProvider The service provider. Methods BeginScope() Starts a resolution scope. Declaration public IDependencyScope BeginScope() Returns Type Description System.Web.Http.Dependencies.IDependencyScope The dependency scope. Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() GetService(Type) Retrieves a service from the scope. Declaration public object GetService(Type serviceType) Parameters Type Name Description System.Type serviceType The service to be retrieved. Returns Type Description System.Object The retrieved service. GetServices(Type) Retrieves a collection of services from the scope. Declaration public IEnumerable<object> GetServices(Type serviceType) Parameters Type Name Description System.Type serviceType The collection of services to be retrieved. Returns Type Description System.Collections.Generic.IEnumerable < System.Object > The retrieved collection of services. Implements System.Web.Http.Dependencies.IDependencyResolver System.Web.Http.Dependencies.IDependencyScope System.IDisposable See Also System.Web.Http.Dependencies.IDependencyResolver"
  },
  "api/extensions/api/XPike.Extensions.DependencyInjection.WebApi.IServiceCollectionExtensions.html": {
    "href": "api/extensions/api/XPike.Extensions.DependencyInjection.WebApi.IServiceCollectionExtensions.html",
    "title": "Class IServiceCollectionExtensions | xPike",
    "keywords": "Class IServiceCollectionExtensions Extension methods for IServiceCollection to support using Microsoft.Extensions.DependencyInjection in ASP.Net WebAPI. Inheritance System.Object IServiceCollectionExtensions Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : XPike.Extensions.DependencyInjection.WebApi Assembly : XPike.Extensions.DependencyInjection.WebApi.dll Syntax public static class IServiceCollectionExtensions Methods AddApiControllers(IServiceCollection) Adds the API controllers to the service collection with a scoped lifetime. Declaration public static IServiceCollection AddApiControllers(this IServiceCollection services) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceCollection services The services. Returns Type Description Microsoft.Extensions.DependencyInjection.IServiceCollection IServiceCollection."
  },
  "api/extensions/api/XPike.Extensions.DependencyInjection.VerificationResult.html": {
    "href": "api/extensions/api/XPike.Extensions.DependencyInjection.VerificationResult.html",
    "title": "Class VerificationResult | xPike",
    "keywords": "Class VerificationResult Encapsulates the result of a failed attempt to verify a registered type in the container. Inheritance System.Object VerificationResult Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : XPike.Extensions.DependencyInjection Assembly : XPike.Extensions.DependencyInjection.dll Syntax public class VerificationResult Constructors VerificationResult(ServiceDescriptor, Exception, String) Initializes a new instance of the VerificationResult class. Declaration public VerificationResult(ServiceDescriptor descriptor, Exception exception = null, string message = null) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.ServiceDescriptor descriptor The ServiceDescriptor being verified. System.Exception exception The exception thrown, if any. System.String message The verification message. Exceptions Type Condition System.ArgumentNullException descriptor Properties Exception Gets the exception that caused the verification to fail. Declaration public Exception Exception { get; } Property Value Type Description System.Exception The exception. Message Gets the verification message. Declaration public string Message { get; } Property Value Type Description System.String The message."
  }
}